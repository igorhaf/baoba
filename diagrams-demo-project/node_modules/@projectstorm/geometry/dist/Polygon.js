import { Point } from './Point';
import * as _ from 'lodash';
import { Matrix } from './Matrix';
import { boundingBoxFromPoints } from './toolkit';
import { BoundsCorner } from './Bounds';
export class Polygon {
    constructor(points = []) {
        this.points = points;
    }
    serialize() {
        return _.map(this.points, (point) => {
            return [point.x, point.y];
        });
    }
    deserialize(data) {
        this.points = _.map(data, (point) => {
            return new Point(point[0], point[1]);
        });
    }
    scale(x, y, origin) {
        let matrix = Matrix.createScaleMatrix(x, y, origin);
        _.forEach(this.points, (point) => {
            point.transform(matrix);
        });
    }
    transform(matrix) {
        _.forEach(this.points, (point) => {
            point.transform(matrix);
        });
    }
    setPoints(points) {
        this.points = points;
    }
    getPoints() {
        return this.points;
    }
    rotate(degrees) {
        this.transform(Matrix.createRotateMatrix(degrees / (180 / Math.PI), this.getOrigin()));
    }
    translate(offsetX, offsetY) {
        _.forEach(this.points, (point) => {
            point.translate(offsetX, offsetY);
        });
    }
    doClone(ob) {
        this.points = _.map(ob.points, (point) => {
            return point.clone();
        });
    }
    clone() {
        let ob = Object.create(this);
        ob.doClone(this);
        return ob;
    }
    getOrigin() {
        if (this.points.length === 0) {
            return null;
        }
        let dimensions = boundingBoxFromPoints(this.points);
        return Point.middlePoint(dimensions[BoundsCorner.TOP_LEFT], dimensions[BoundsCorner.BOTTOM_RIGHT]);
    }
    getBoundingBox() {
        return boundingBoxFromPoints(this.points);
    }
}
//# sourceMappingURL=Polygon.js.map