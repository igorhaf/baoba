!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports["projectstorm/react-diagrams-routing"]=e():t["projectstorm/react-diagrams-routing"]=e()}(self,(()=>(()=>{"use strict";var t={d:(e,i)=>{for(var n in i)t.o(i,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:i[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{DagreEngine:()=>k,PathFinding:()=>h,PathFindingLinkFactory:()=>d,PathFindingLinkModel:()=>s,PathFindingLinkWidget:()=>g,RightAngleLinkFactory:()=>m,RightAngleLinkModel:()=>P,RightAngleLinkWidget:()=>f});const i=require("react"),n=require("@projectstorm/react-diagrams-defaults");class s extends n.DefaultLinkModel{constructor(t={}){super(Object.assign({type:d.NAME},t))}performanceTune(){return!1}}const o=require("lodash"),r=require("pathfinding"),a=new r.JumpPointFinder({heuristic:r.Heuristic.manhattan,diagonalMovement:r.DiagonalMovement.Never});class h{constructor(t){this.instance=a,this.factory=t}calculateDirectPath(t,e){const i=this.factory.getCanvasMatrix(),n=new r.Grid(i);return a.findPath(this.factory.translateRoutingX(Math.floor(t.getX()/this.factory.ROUTING_SCALING_FACTOR)),this.factory.translateRoutingY(Math.floor(t.getY()/this.factory.ROUTING_SCALING_FACTOR)),this.factory.translateRoutingX(Math.floor(e.getX()/this.factory.ROUTING_SCALING_FACTOR)),this.factory.translateRoutingY(Math.floor(e.getY()/this.factory.ROUTING_SCALING_FACTOR)),n)}calculateLinkStartEndCoords(t,e){const i=e.findIndex((e=>!!t[e[1]]&&0===t[e[1]][e[0]])),n=e.length-1-e.slice().reverse().findIndex((e=>!!t[e[1]]&&0===t[e[1]][e[0]]));if(-1===i||-1===n)return;const s=e.slice(0,i),o=e.slice(n);return{start:{x:e[i][0],y:e[i][1]},end:{x:e[n][0],y:e[n][1]},pathToStart:s,pathToEnd:o}}calculateDynamicPath(t,e,i,n,s){const o=new r.Grid(t),h=a.findPath(e.x,e.y,i.x,i.y,o),g=n.concat(h,s).map((t=>[this.factory.translateRoutingX(t[0],!0),this.factory.translateRoutingY(t[1],!0)]));return r.Util.compressPath(g)}}class g extends i.Component{constructor(t){super(t),this.refPaths=[],this.state={selected:!1},this.pathFinding=new h(this.props.factory)}componentDidUpdate(){this.props.link.setRenderedPaths(this.refPaths.map((t=>t.current)))}componentDidMount(){this.props.link.setRenderedPaths(this.refPaths.map((t=>t.current)))}componentWillUnmount(){this.props.link.setRenderedPaths([])}generateLink(t,e){const s=i.createRef();return this.refPaths.push(s),i.createElement(n.DefaultLinkSegmentWidget,{key:`link-${e}`,path:t,selected:this.state.selected,diagramEngine:this.props.diagramEngine,factory:this.props.diagramEngine.getFactoryForLink(this.props.link),link:this.props.link,forwardRef:s,onSelection:t=>{this.setState({selected:t})},extras:{}})}render(){this.refPaths=[];var t=this.props.link.getPoints(),e=[];const n=this.pathFinding.calculateDirectPath(o.first(t),o.last(t)),s=this.props.factory.getRoutingMatrix(),r=this.pathFinding.calculateLinkStartEndCoords(s,n);if(r){const{start:t,end:i,pathToStart:n,pathToEnd:o}=r,a=this.pathFinding.calculateDynamicPath(s,t,i,n,o);e.push(this.generateLink(this.props.factory.generateDynamicPath(a),"0"))}return i.createElement(i.Fragment,null,e)}}const l=require("paths-js/path"),c=require("@projectstorm/react-canvas-core");class d extends n.DefaultLinkFactory{constructor(){super(d.NAME),this.ROUTING_SCALING_FACTOR=5,this.canvasMatrix=[],this.routingMatrix=[],this.hAdjustmentFactor=0,this.vAdjustmentFactor=0,this.calculateMatrixDimensions=()=>{const t=o.values(this.engine.getModel().getNodes()).map((t=>({x:t.getX(),width:t.width,y:t.getY(),height:t.height}))),e=o.values(this.engine.getModel().getLinks()),i=o.flatMap(e.map((t=>[t.getSourcePort(),t.getTargetPort()]))).filter((t=>null!==t)).map((t=>({x:t.getX(),width:t.width,y:t.getY(),height:t.height}))),n=o.flatMap(e.map((t=>t.getPoints()))).map((t=>({x:t.getX(),width:0,y:t.getY(),height:0}))),s=(t,e)=>o.reduce(e,((e,i)=>e+o.get(t,i,0)),0),r=this.engine.getCanvas(),a=o.concat(t,i,n),h=Math.floor(Math.min(o.get(o.minBy(a,"x"),"x",0),0)/this.ROUTING_SCALING_FACTOR)*this.ROUTING_SCALING_FACTOR,g=o.maxBy(a,(t=>s(t,["x","width"]))),l=Math.max(s(g,["x","width"]),r.offsetWidth),c=o.minBy(a,"y"),d=Math.floor(Math.min(o.get(c,"y",0),0)/this.ROUTING_SCALING_FACTOR)*this.ROUTING_SCALING_FACTOR,p=o.maxBy(a,(t=>s(t,["y","height"]))),u=Math.max(s(p,["y","height"]),r.offsetHeight);return{width:Math.ceil(Math.abs(h)+l),hAdjustmentFactor:Math.abs(h)/this.ROUTING_SCALING_FACTOR+1,height:Math.ceil(Math.abs(d)+u),vAdjustmentFactor:Math.abs(d)/this.ROUTING_SCALING_FACTOR+1}},this.markNodes=t=>{o.values(this.engine.getModel().getNodes()).forEach((e=>{const i=Math.floor(e.getX()/this.ROUTING_SCALING_FACTOR),n=Math.ceil((e.getX()+e.width)/this.ROUTING_SCALING_FACTOR),s=Math.floor(e.getY()/this.ROUTING_SCALING_FACTOR),o=Math.ceil((e.getY()+e.height)/this.ROUTING_SCALING_FACTOR);for(let e=i-1;e<=n+1;e++)for(let i=s-1;i<o+1;i++)this.markMatrixPoint(t,this.translateRoutingX(e),this.translateRoutingY(i))}))},this.markPorts=t=>{o.flatMap(o.values(this.engine.getModel().getLinks()).map((t=>[].concat(t.getSourcePort(),t.getTargetPort())))).filter((t=>null!==t)).forEach((e=>{const i=Math.floor(e.x/this.ROUTING_SCALING_FACTOR),n=Math.ceil((e.x+e.width)/this.ROUTING_SCALING_FACTOR),s=Math.floor(e.y/this.ROUTING_SCALING_FACTOR),o=Math.ceil((e.y+e.height)/this.ROUTING_SCALING_FACTOR);for(let e=i-1;e<=n+1;e++)for(let i=s-1;i<o+1;i++)this.markMatrixPoint(t,this.translateRoutingX(e),this.translateRoutingY(i))}))},this.markMatrixPoint=(t,e,i)=>{void 0!==t[i]&&void 0!==t[i][e]&&(t[i][e]=1)}}setDiagramEngine(t){super.setDiagramEngine(t),t.getStateMachine().registerListener({stateChanged:e=>{if(e.newState instanceof c.AbstractDisplacementState){const e=t.getActionEventBus().registerAction(new c.Action({type:c.InputType.MOUSE_UP,fire:()=>{this.calculateRoutingMatrix(),t.repaintCanvas(),e()}}))}}}),this.listener=t.registerListener({canvasReady:()=>{o.defer((()=>{this.calculateRoutingMatrix(),t.repaintCanvas()}))}})}setFactoryBank(t){super.setFactoryBank(t),!t&&this.listener&&this.listener.deregister()}generateReactWidget(t){return i.createElement(g,{diagramEngine:this.engine,link:t.model,factory:this})}generateModel(t){return new s}getCanvasMatrix(){return 0===this.canvasMatrix.length&&this.calculateCanvasMatrix(),this.canvasMatrix}calculateCanvasMatrix(){const{width:t,hAdjustmentFactor:e,height:i,vAdjustmentFactor:n}=this.calculateMatrixDimensions();this.hAdjustmentFactor=e,this.vAdjustmentFactor=n;const s=Math.ceil(t/this.ROUTING_SCALING_FACTOR),r=Math.ceil(i/this.ROUTING_SCALING_FACTOR);this.canvasMatrix=o.range(0,r).map((()=>new Array(s).fill(0)))}getRoutingMatrix(){return 0===this.routingMatrix.length&&this.calculateRoutingMatrix(),this.routingMatrix}calculateRoutingMatrix(){const t=o.cloneDeep(this.getCanvasMatrix());this.markNodes(t),this.markPorts(t),this.routingMatrix=t}translateRoutingX(t,e=!1){return t+this.hAdjustmentFactor*(e?-1:1)}translateRoutingY(t,e=!1){return t+this.vAdjustmentFactor*(e?-1:1)}generateDynamicPath(t){let e=l();return e=e.moveto(t[0][0]*this.ROUTING_SCALING_FACTOR,t[0][1]*this.ROUTING_SCALING_FACTOR),t.slice(1).forEach((t=>{e=e.lineto(t[0]*this.ROUTING_SCALING_FACTOR,t[1]*this.ROUTING_SCALING_FACTOR)})),e.print()}}d.NAME="pathfinding";const p=require("@projectstorm/react-diagrams-core"),u=require("@projectstorm/geometry");class f extends i.Component{constructor(t){super(t),this.handleMove=function(t){this.draggingEvent(t,this.dragging_index)}.bind(this),this.handleUp=function(t){this.setState({canDrag:!1,selected:!1}),window.removeEventListener("mousemove",this.handleMove),window.removeEventListener("mouseup",this.handleUp)}.bind(this),this.refPaths=[],this.state={selected:!1,canDrag:!1},this.dragging_index=0}componentDidUpdate(){this.props.link.setRenderedPaths(this.refPaths.map((t=>t.current)))}componentDidMount(){this.props.link.setRenderedPaths(this.refPaths.map((t=>t.current)))}componentWillUnmount(){this.props.link.setRenderedPaths([])}generateLink(t,e,s){const o=i.createRef();return this.refPaths.push(o),i.createElement(n.DefaultLinkSegmentWidget,{key:`link-${s}`,path:t,selected:this.state.selected,diagramEngine:this.props.diagramEngine,factory:this.props.diagramEngine.getFactoryForLink(this.props.link),link:this.props.link,forwardRef:o,onSelection:t=>{this.setState({selected:t})},extras:e})}calculatePositions(t,e,i,n){if(0===i){let e=new p.PointModel({link:this.props.link,position:new u.Point(t[i].getX(),t[i].getY())});return this.props.link.addPoint(e,i),void this.dragging_index++}if(i===t.length-2){let e=new p.PointModel({link:this.props.link,position:new u.Point(t[i+1].getX(),t[i+1].getY())});return void this.props.link.addPoint(e,i+1)}if(i-2>0){let s={[i-2]:t[i-2].getPosition(),[i+1]:t[i+1].getPosition(),[i-1]:t[i-1].getPosition()};if(Math.abs(s[i-1][n]-s[i+1][n])<5)return s[i-2][n]=this.props.diagramEngine.getRelativeMousePoint(e)[n],s[i+1][n]=this.props.diagramEngine.getRelativeMousePoint(e)[n],t[i-2].setPosition(s[i-2]),t[i+1].setPosition(s[i+1]),t[i-1].remove(),t[i-1].remove(),this.dragging_index--,void this.dragging_index--}if(i+2<t.length-2){let s={[i+3]:t[i+3].getPosition(),[i+2]:t[i+2].getPosition(),[i+1]:t[i+1].getPosition(),[i]:t[i].getPosition()};if(Math.abs(s[i+1][n]-s[i+2][n])<5)return s[i][n]=this.props.diagramEngine.getRelativeMousePoint(e)[n],s[i+3][n]=this.props.diagramEngine.getRelativeMousePoint(e)[n],t[i].setPosition(s[i]),t[i+3].setPosition(s[i+3]),t[i+1].remove(),void t[i+1].remove()}let s={[i]:t[i].getPosition(),[i+1]:t[i+1].getPosition()};s[i][n]=this.props.diagramEngine.getRelativeMousePoint(e)[n],s[i+1][n]=this.props.diagramEngine.getRelativeMousePoint(e)[n],t[i].setPosition(s[i]),t[i+1].setPosition(s[i+1])}draggingEvent(t,e){let i=this.props.link.getPoints(),n=Math.abs(i[e].getX()-i[e+1].getX()),s=Math.abs(i[e].getY()-i[e+1].getY());0===n?this.calculatePositions(i,t,e,"x"):0===s&&this.calculatePositions(i,t,e,"y"),this.props.link.setFirstAndLastPathsDirection()}render(){let t=this.props.link.getPoints(),e=[],n=t[0],s=t[t.length-1],o=!1;n.getX()>s.getX()&&(n=t[t.length-1],s=t[0],o=!0);let r=Math.abs(t[0].getY()-t[t.length-1].getY());if(null===this.props.link.getTargetPort()&&2===t.length)[...Array(2)].forEach((t=>{this.props.link.addPoint(new p.PointModel({link:this.props.link,position:new u.Point(n.getX(),s.getY())}),1)})),this.props.link.setManuallyFirstAndLastPathsDirection(!0,!0);else if(null===this.props.link.getTargetPort()&&null!==this.props.link.getSourcePort())t[1].setPosition(s.getX()+(n.getX()-s.getX())/2,o?s.getY():n.getY()),t[2].setPosition(s.getX()+(n.getX()-s.getX())/2,o?n.getY():s.getY());else if(!this.state.canDrag&&t.length>2)for(let e=1;e<t.length;e+=t.length-2)e-1==0?this.props.link.getFirstPathXdirection()?t[e].setPosition(t[e].getX(),t[e-1].getY()):t[e].setPosition(t[e-1].getX(),t[e].getY()):this.props.link.getLastPathXdirection()?t[e-1].setPosition(t[e-1].getX(),t[e].getY()):t[e-1].setPosition(t[e].getX(),t[e-1].getY());2!==t.length||0===r||this.state.canDrag||this.props.link.addPoint(new p.PointModel({link:this.props.link,position:new u.Point(n.getX(),s.getY())}));for(let i=0;i<t.length-1;i++)e.push(this.generateLink(p.LinkWidget.generateLinePath(t[i],t[i+1]),{"data-linkid":this.props.link.getID(),"data-point":i,onMouseDown:t=>{0===t.button&&(this.setState({canDrag:!0}),this.dragging_index=i,window.addEventListener("mousemove",this.handleMove),window.addEventListener("mouseup",this.handleUp))},onMouseEnter:t=>{this.setState({selected:!0}),this.props.link.lastHoverIndexOfPath=i}},i));return this.refPaths=[],i.createElement("g",{"data-default-link-test":this.props.link.getOptions().testName},e)}}f.defaultProps={color:"red",width:3,link:null,smooth:!1,diagramEngine:null,factory:null};class P extends n.DefaultLinkModel{constructor(t={}){super(Object.assign({type:m.NAME},t)),this.lastHoverIndexOfPath=0,this._lastPathXdirection=!1,this._firstPathXdirection=!1}setFirstAndLastPathsDirection(){let t=this.getPoints();for(let e=1;e<t.length;e+=t.length-2){let i=Math.abs(t[e].getX()-t[e-1].getX()),n=Math.abs(t[e].getY()-t[e-1].getY());e-1==0?this._firstPathXdirection=i>n:this._lastPathXdirection=i>n}}addPoint(t,e=1){return super.addPoint(t,e),this.setFirstAndLastPathsDirection(),t}deserialize(t){super.deserialize(t),this.setFirstAndLastPathsDirection()}setManuallyFirstAndLastPathsDirection(t,e){this._firstPathXdirection=t,this._lastPathXdirection=e}getLastPathXdirection(){return this._lastPathXdirection}getFirstPathXdirection(){return this._firstPathXdirection}setWidth(t){this.options.width=t,this.fireEvent({width:t},"widthChanged")}setColor(t){this.options.color=t,this.fireEvent({color:t},"colorChanged")}}class m extends n.DefaultLinkFactory{constructor(){super(m.NAME)}generateModel(t){return new P}generateReactWidget(t){return i.createElement(f,{diagramEngine:this.engine,link:t.model,factory:this})}}m.NAME="rightAngle";const M=require("dagre");class k{constructor(t={}){this.options=t}redistribute(t){var e=new M.graphlib.Graph({multigraph:!0,compound:!0});e.setGraph(this.options.graph||{}),e.setDefaultEdgeLabel((function(){return{}})),o.forEach(t.getNodes(),(t=>{e.setNode(t.getID(),{width:t.width,height:t.height})})),o.forEach(t.getLinks(),(t=>{t.getSourcePort()&&t.getTargetPort()&&e.setEdge({v:t.getSourcePort().getNode().getID(),w:t.getTargetPort().getNode().getID(),name:t.getID()})})),M.layout(e),e.nodes().forEach((i=>{const n=e.node(i);t.getNode(i).setPosition(n.x-n.width/2,n.y-n.height/2)})),this.options.includeLinks&&e.edges().forEach((i=>{const n=e.edge(i),s=t.getLink(i.name),o=[s.getFirstPoint()];for(let t=1;t<n.points.length-1;t++)o.push(new p.PointModel({link:s,position:new u.Point(n.points[t].x,n.points[t].y)}));s.setPoints(o.concat(s.getLastPoint()))}))}refreshLinks(t){const{nodeMargin:e}=this.options,i=t.getNodes(),n=t.getLinks();let s=-1;const r={},a={};let h=[];o.forEach(i,(t=>{const i=t.getX()+t.width/2;o.every(h,(t=>Math.abs(i-t)>e))&&h.push(i)})),h=h.sort(((t,e)=>t-e)),o.forEach(h,((t,e)=>{r[e]={},r[e+.5]={}})),o.forEach(i,(t=>{const i=t.getX()+t.width/2,n=Math.floor(t.getY()/e),g=Math.floor((t.getY()+t.height)/e);g>s&&(s=g);const l=o.findIndex(h,(t=>Math.abs(i-t)<=e));o.forEach(o.range(n,g+1),(t=>{r[l][t]=!0})),a[t.getX()]=l}));const g=o.map(n,(t=>{if(t.getSourcePort()&&t.getTargetPort()){const e=t.getSourcePort().getNode(),i=t.getTargetPort().getNode(),n=a[e.getX()],s=a[i.getX()];return n>s?{link:t,sourceIndex:n,sourceY:e.getY()+e.height/2,source:e,targetIndex:s,targetY:i.getY()+e.height/2,target:i}:{link:t,sourceIndex:s,sourceY:i.getY()+i.height/2,source:i,targetIndex:n,targetY:e.getY()+e.height/2,target:e}}})),l=o.sortBy(g,(t=>Math.abs(t.targetIndex-t.sourceIndex)));this.options.includeLinks&&o.forEach(l,(i=>{const n=t.getLink(i.link.getID());if(Math.abs(i.sourceIndex-i.targetIndex)>1){const t=o.range(i.sourceIndex-1,i.targetIndex),a=Math.floor(i.sourceY/e),g=Math.floor(i.targetY/e);let l=1,c=a;for(;c>=0&&!o.every(t,(t=>!(r[t][c]||r[t+.5][c]||r[t-.5][c])));c--,l++);let d=0,f=a;for(;f<=s&&!o.every(t,(t=>!(r[t][f]||r[t+.5][f]||r[t-.5][f])));f++,d++);const P=d+(f-g)<l+(g-c)?f+1:c-1,m=[n.getFirstPoint()];m.push(new p.PointModel({link:n,position:new u.Point((h[t[0]]+h[t[0]+1])/2,(P+.5)*e)})),o.forEach(t,(t=>{m.push(new p.PointModel({link:n,position:new u.Point(h[t],(P+.5)*e)})),m.push(new p.PointModel({link:n,position:new u.Point((h[t]+h[t-1])/2,(P+.5)*e)})),r[t][P]=!0,r[t][P+1]=!0,r[t+.5][P]=!0,r[t+.5][P+1]=!0})),n.setPoints(m.concat(n.getLastPoint()))}else{n.setPoints([n.getFirstPoint(),n.getLastPoint()]);const t=(i.sourceIndex+i.targetIndex)/2;r[t]||(r[t]={});const s=Math.floor((i.sourceY+i.targetY)/2/e);r[t][s]=!0,r[t][s+1]=!0}}))}}return e})()));
//# sourceMappingURL=index.umd.js.map